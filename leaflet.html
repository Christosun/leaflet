<!DOCTYPE html>
<html>
<head>
  <title>Leaflet + InfluxDB - Optimized</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <!-- Preconnect to external resources for faster loading -->
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="dns-prefetch" href="https://backend.flotech.co.id">
  <link rel="dns-prefetch" href="https://mts1.google.com">
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" media="print" onload="this.media='all'">
  
  <style>
    /* Critical CSS - Inline untuk faster first paint */
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden; /* Prevent scroll bounce on mobile */
    }
    
    #map { 
      height: 100vh; 
      width: 100vw;
      /* Hardware acceleration */
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    
    /* Optimized animations - Use transform instead of position changes */
    .legend {
      background: rgba(30, 30, 30, 0.7); 
      padding: 14px; 
      font-size: 14px; 
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15); 
      font-family: 'Segoe UI', sans-serif;
      min-width: 160px; 
      backdrop-filter: blur(4px);
      /* Performance optimization */
      will-change: auto;
      contain: layout style paint;
    }
    
    .legend-title { 
      font-weight: bold; 
      margin-bottom: 10px; 
      font-size: 12px; 
      color: #ffffff; 
    }
    
    .legend button {
      width: 100%; 
      padding: 8px 10px; 
      margin-bottom: 6px; 
      background-color: rgba(29, 28, 28, 0.7);
      border: none; 
      border-radius: 6px; 
      cursor: pointer; 
      text-align: left; 
      font-size: 11px; 
      color: #ffffff; 
      display: flex; 
      align-items: center; 
      gap: 6px;
      /* Optimized transition - only transform */
      transition: transform 0.2s ease, background 0.2s ease;
      will-change: transform;
    }
    
    .legend button:hover { 
      background: rgba(255,255,255,0.15); 
      transform: translateX(4px); 
    }

    .leaflet-control-home {
      background: rgba(30, 30, 30, 0.7); 
      border: none !important; 
      border-radius: 12px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65); 
      width: 45px; 
      height: 45px; 
      backdrop-filter: blur(4px);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      cursor: pointer; 
      margin-top: 10px;
      transition: background-color 0.2s ease;
    }

    .leaflet-control-home i {
      font-size: 22px;
      color: #ffffff;
      transition: color 0.2s ease;
    }
    
    .leaflet-control-home:hover { 
      background-color: #474646; 
    }

    /* Switch button */
    .switch-control {
      background: rgba(30, 30, 30, 0.7); 
      backdrop-filter: blur(4px); 
      padding: 8px 12px; 
      border-radius: 20px; 
      display: flex; 
      align-items: center;
      gap: 8px; 
      font-family: 'Segoe UI', sans-serif; 
      font-size: 12px; 
      color: #ffffff; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .switch {
      position: relative; 
      display: inline-block; 
      width: 40px; 
      height: 20px;
    }
    
    .switch input { 
      opacity: 0; 
      width: 0; 
      height: 0; 
    }
    
    .slider {
      position: absolute; 
      cursor: pointer; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0;
      background-color: #ccc; 
      transition: background-color 0.3s ease;
      border-radius: 20px;
    }
    
    .slider:before {
      position: absolute; 
      content: ""; 
      height: 14px; 
      width: 14px; 
      left: 3px; 
      bottom: 3px;
      background-color: white; 
      transition: transform 0.3s ease;
      border-radius: 50%;
      will-change: transform;
    }
    
    input:checked + .slider { 
      background-color: #4CAF50; 
    }
    
    input:checked + .slider:before { 
      transform: translateX(20px); 
    }

    /* Label besar - Optimized */
    .custom-label {
      background: rgba(30, 30, 30, 0.7); 
      padding: 12px 16px; 
      border-radius: 12px;
      color: #fff; 
      font-family: 'Segoe UI', sans-serif; 
      font-size: 11px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.15); 
      backdrop-filter: blur(4px);
      min-width: 140px; 
      position: relative; 
      z-index: 1;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      will-change: transform;
      /* Performance boost */
      contain: layout style paint;
    }
    
    .custom-label.hovered {
      transform: scale(1.15) translateY(-4px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
      border-color: rgba(255, 255, 255, 0.35);
      z-index: 1000;
    }
    
    .custom-label .device-id {
      font-weight: bold; 
      font-size: 12px; 
      margin-bottom: 8px; 
      color: #ffffff;
    }
    
    .custom-label .info-row { 
      display: flex; 
      justify-content: space-between; 
      margin-bottom: 4px; 
    }
    
    .custom-label .info-row:last-child { 
      margin-bottom: 0; 
    }
    
    .custom-label .label { 
      color: #ddd; 
      font-weight: 500; 
    }
    
    .custom-label .value { 
      font-weight: bold; 
      color: #fff; 
    }

    /* Mini label - Optimized */
    .mini-label {
      display: inline-block;
      font-weight: bold;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(30, 30, 30, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.2);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
      color: #fbfbfb;
      white-space: nowrap;
      line-height: 1.2em;
      font-family: 'Segoe UI', sans-serif;
      /* Performance */
      will-change: auto;
      contain: layout style paint;
    }

    /* Layer switcher modern */
    .leaflet-control-layers {
      background: rgba(30, 30, 30, 0.7) !important;
      border-radius: 12px !important;
      border: none !important;
      backdrop-filter: blur(4px);
      padding: 8px !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-family: 'Segoe UI', sans-serif;
    }

    .leaflet-control-layers-list {
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .leaflet-control-layers-selector {
      display: none;
    }

    .leaflet-control-layers-base label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      background: rgba(29, 28, 28, 0.7);
      transition: transform 0.2s ease, background 0.2s ease;
      font-size: 12px;
      color: #fff;
      will-change: transform;
    }

    .leaflet-control-layers-base label:hover {
      background: rgba(255,255,255,0.15);
      transform: translateX(4px);
    }

    .leaflet-control-layers-base label span.icon {
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: rgba(255,255,255,0.15);
      font-size: 12px;
    }

    .leaflet-control-layers-base input:checked + span {
      font-weight: bold;
      color: #2ecc46;
    }

    /* Optimized legend content scroll */
    #legendContent {
      max-height: 275px;
      overflow-y: auto;
      padding-right: 4px;
      /* Smooth scroll on mobile */
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }

    /* Slim scrollbar */
    #legendContent::-webkit-scrollbar {
      width: 6px;
    }

    #legendContent::-webkit-scrollbar-track {
      background: transparent;
    }

    #legendContent::-webkit-scrollbar-thumb {
      background: rgba(180, 180, 180, 0.6);
      border-radius: 4px;
    }

    #legendContent::-webkit-scrollbar-thumb:hover {
      background: rgba(150, 150, 150, 0.9);
    }

    #legendContent {
      scrollbar-width: thin;
      scrollbar-color: rgba(180,180,180,0.6) transparent;
    }

    /* Optimized blinking animations - Use opacity instead of filter */
    .blinking-marker {
      animation: blinkMarker 1s infinite;
    }
    
    @keyframes blinkMarker {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    .blinking-dot {
      animation: blinkDot 1s infinite;
    }
    
    @keyframes blinkDot {
      0%, 100% { background: red; }
      50% { background: darkred; }
    }

    .legend.flowrate {
      background: rgba(30, 30, 30, 0.7);
      width: 75%;
      font-size: 11px;
      line-height: 1.3em;
      contain: layout style paint;
    }

    /* Optimized animations - Use transform only */
    @keyframes pop {
      0% { transform: scale(1); }
      40% { transform: scale(0.8); }
      100% { transform: scale(1); }
    }

    .leaflet-control-home.active {
      animation: pop 0.5s ease-out;
    }

    /* Zoom controls */
    .leaflet-control-zoom a {
      background-color: rgba(30, 30, 30, 0.7) !important; 
      color: #fff !important; 
      border: none !important;
      transition: background-color 0.2s ease;
    }
    
    .leaflet-control-zoom a:hover {
      background-color: #474646 !important;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .legend {
        font-size: 12px;
        padding: 10px;
        min-width: 140px;
      }

      .custom-label {
        font-size: 10px;
        padding: 10px 12px;
        min-width: 120px;
      }

      .mini-label {
        font-size: 10px;
        padding: 3px 6px;
      }

      .switch-control {
        padding: 6px 10px;
        font-size: 11px;
      }

      .leaflet-control-home {
        width: 40px;
        height: 40px;
      }

      .leaflet-control-home i {
        font-size: 18px;
      }
    }

    /* Loading indicator */
    .loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10000;
      display: none;
    }

    .loading-indicator.show {
      display: block;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="loading-indicator" id="loadingIndicator">
  <div class="spinner"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  // ========== PERFORMANCE OPTIMIZATIONS ==========
  
  // 1. Debounce function for expensive operations
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // 2. Throttle function for scroll/zoom events
  function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  // 3. Request Animation Frame wrapper
  const requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           function(callback) {
             window.setTimeout(callback, 1000 / 60);
           };
  })();

  // ========== MAP INITIALIZATION ==========
  
  // Tile layers with performance optimizations
  const tileOptions = {
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
    maxNativeZoom: 18
  };

  const grayscale = L.tileLayer(
    'https://mts1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
    { ...tileOptions, attribution: '' }
  );

  const satellite = L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { ...tileOptions, attribution: '' }
  );

  const darkmaps = L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
    { ...tileOptions, attribution: '' }
  );

  // Map initialization with performance settings
  const map = L.map('map', {
    scrollWheelZoom: false,
    gestureHandling: true,
    layers: [grayscale],
    zoomControl: false,
    attributionControl: false,
    preferCanvas: true, // Use Canvas for better performance with many markers
    renderer: L.canvas({ padding: 0.5 })
  }).setView([-2.5, 117], 5);

  // Optimized wheel zoom
  map.getContainer().addEventListener('wheel', throttle(e => {
    if (e.ctrlKey) {
      map.scrollWheelZoom.enable();
    } else {
      map.scrollWheelZoom.disable();
    }
  }, 100));

  // Mobile optimizations
  if (/Mobi|Android/i.test(navigator.userAgent)) {
    map.dragging.disable();
    map.touchZoom.enable();
    
    let touchCount = 0;
    map.on('touchstart', e => {
      touchCount = e.originalEvent.touches.length;
      if (touchCount === 2) {
        map.dragging.enable();
      } else {
        map.dragging.disable();
      }
    });
  }

  // Base maps with icons
  const baseMaps = {
    "<span class='icon'><i class='fa-solid fa-map'></i></span> Grayscale": grayscale,
    "<span class='icon'><i class='fa-solid fa-globe'></i></span> Satellite": satellite,
    "<span class='icon'><i class='fa-solid fa-moon'></i></span> Dark Maps": darkmaps
  };
  
  L.control.layers(baseMaps, null, { collapsed: false }).addTo(map);

  // ========== CONTROLS ==========
  
  // Home button
  const homeControl = L.Control.extend({
    options: { position: 'topright' },
    onAdd: function(map) {
      const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-home');
      container.innerHTML = '<i class="fas fa-rotate"></i>';
      container.onclick = function() {
        if (window.initialBounds) {
          map.flyToBounds(window.initialBounds, {
            paddingTopLeft: [50, 50],
            paddingBottomRight: [120, 150],
            duration: 0.8
          });
        }
        restartAnimation(container, "active");
      };
      return container;
    }
  });

  function restartAnimation(el, className) {
    el.classList.remove(className);
    void el.offsetWidth;
    el.classList.add(className);
  }

  // Switch control
  const switchControl = L.Control.extend({
    options: { position: 'topright' },
    onAdd: function(map) {
      const div = L.DomUtil.create('div', 'switch-control');
      div.innerHTML = `
        <label class="switch">
          <input type="checkbox" id="labelSwitch" checked>
          <span class="slider"></span>
        </label>
        <span id="switchLabel">Label ON</span>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    }
  });

  map.addControl(new switchControl());
  map.addControl(new homeControl());

  // ========== MARKER ICONS - CACHED ==========
  
  const iconCache = {};
  
  function createIcon(color) {
    if (iconCache[color]) return iconCache[color];
    
    const urlMap = {
      red: "marker-icon-2x-red.png",
      yellow: "marker-icon-2x-yellow.png",
      green: "marker-icon-2x-green.png",
      blue: "marker-icon-2x-blue.png"
    };

    iconCache[color] = new L.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/${urlMap[color]}`,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize: [22, 35],
      iconAnchor: [11, 35],
      popupAnchor: [1, -28],
      shadowSize: [35, 35]
    });

    return iconCache[color];
  }

  // ========== STATE MANAGEMENT ==========
  
  let isFirstLoad = true;
  let hoveredDevice = null;
  let markerGroup = L.layerGroup().addTo(map);
  let labelGroup = L.layerGroup().addTo(map);
  let miniLabelGroup = L.layerGroup().addTo(map);
  let labelsVisible = true;
  let deviceStatus = {};
  let isHoverLocked = false;
  let updateInProgress = false;

  const deviceLocations = {
    "FM-001": [-0.57969, 117.08502],
    "FM-002": [-0.860054, 117.21362],
    "FM-003": [-0.427323, 117.009778],
    "FM-004": [-0.3285, 116.83249],
    "FM-005": [-0.57232, 117.26649],
    "FM-006": [-0.4083402, 116.9902031],
    "FM-007": [-0.52148, 116.41944],
    "FM-008": [0.567008, 116.017198],
    "FM-009": [-0.111113, 117.436818],
    "FM-010": [-0.59382, 117.03557],
    "FM-011": [0.138653, 116.376306],
    "FM-012": [-0.009895, 116.415856],
    "FM-013": [-0.24324, 116.8084],
    "FM-014": [-0.33074, 117.38472],
    "FM-015": [-0.67147, 117.22216],
    "FM-016": [-0.41583, 116.29076]
  };

  // ========== LEGEND ==========
  
  const legend = L.control({ position: 'topleft' });
  legend.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'legend');
    div.innerHTML = '<div class="legend-title">LOCATION LIST:</div><div id="legendContent"></div>';
    return div;
  };

  const flowLegend = L.control({ position: 'bottomleft' });
  flowLegend.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'legend flowrate');
    div.innerHTML = `
      <div style="color:white"><span style="color:red;">ðŸ”´</span> Low flow: &lt; 10 l/s</div>
      <div style="color:white"><span style="color:gold;">ðŸŸ¡</span> Medium flow: &lt; 50 l/s</div>
      <div style="color:white"><span style="color:limegreen;">ðŸŸ¢</span> High flow: &lt; 100 l/s</div>
      <div style="color:white"><span style="color:deepskyblue;">ðŸ”µ</span> Very high flow: â‰¥ 100 l/s</div>
      <div style="color:white"><span style="color:red;">ðŸ”´</span> Red blinking: Device offline</div>
    `;
    return div;
  };

  window.zoomTo = function(id) {
    const c = deviceLocations[id];
    if (c) map.flyTo(c, 18, { duration: 0.8 });
  };

  legend.addTo(map);
  flowLegend.addTo(map);

  // ========== OPTIMIZED UPDATE LEGEND ==========
  
  const updateLegend = debounce(function() {
    const container = document.getElementById("legendContent");
    if (!container) return;

    // Use DocumentFragment for better performance
    const fragment = document.createDocumentFragment();

    Object.keys(deviceLocations).forEach(id => {
      const status = deviceStatus[id] || {};
      const isOnline = status._time && (Date.now() - new Date(status._time).getTime() < 60000);

      const button = document.createElement('button');
      button.onclick = () => zoomTo(id);

      const dot = document.createElement('span');
      dot.className = isOnline ? '' : 'blinking-dot';
      dot.style.cssText = `
        width:10px;
        height:10px;
        border-radius:50%;
        display:inline-block;
        margin-right:6px;
        ${isOnline ? 'background:limegreen;' : ''}
      `;

      button.appendChild(dot);
      button.appendChild(document.createTextNode(id));
      fragment.appendChild(button);
    });

    // Single DOM update
    container.innerHTML = '';
    container.appendChild(fragment);
  }, 100);

  // ========== GET FLOW ICON - OPTIMIZED ==========
  
  function getFlowIcon(flowrate, isOnline) {
    if (!isOnline) {
      return L.divIcon({
        className: 'blinking-marker',
        html: `<img src="https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png"
                style="width:22px;height:35px;" />`,
        iconAnchor: [11, 35]
      });
    }

    let color = "green";
    if (flowrate < 10) color = "red";
    else if (flowrate < 50) color = "yellow";
    else if (flowrate < 100) color = "green";
    else color = "blue";

    return createIcon(color);
  }

  // ========== OPTIMIZED DATA FETCHING ==========
  
  let abortController = null;
  
  async function getData() {
    // Cancel previous request if still pending
    if (abortController) {
      abortController.abort();
    }
    
    abortController = new AbortController();
    
    try {
      const res = await fetch("https://backend.flotech.co.id/flowdata", {
        signal: abortController.signal,
        cache: 'no-cache'
      });
      
      if (!res.ok) throw new Error('Network response was not ok');
      
      const data = await res.json();
      return data.map(d => ({
        device_id: d.device_id,
        Flowrate: d.Flowrate,
        Totalizer: d.Totalizer,
        lat: d.lat,
        lon: d.lon,
        _time: d._time
      }));
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Fetch aborted');
      } else {
        console.error('Fetch error:', error);
      }
      return [];
    }
  }

  // ========== HOVER MANAGEMENT ==========
  
  function setHover(active, id) {
    if (active) {
      hoveredDevice = id;
      isHoverLocked = true;
    } else {
      hoveredDevice = null;
      isHoverLocked = false;
    }

    // Batch DOM updates
    requestAnimFrame(() => {
      document.querySelectorAll('.custom-label').forEach(el => {
        el.classList.remove('hovered');
        el.style.zIndex = 1;
        if (el.closest('.leaflet-marker-icon')) {
          el.closest('.leaflet-marker-icon').style.zIndex = '';
        }
      });

      if (active) {
        const lbl = document.getElementById(`label-${id}`);
        if (lbl) {
          lbl.classList.add('hovered');
          lbl.style.zIndex = 1000;
          const markerWrapper = lbl.closest('.leaflet-marker-icon');
          if (markerWrapper) markerWrapper.style.zIndex = 9999;
        }
      }
    });
  }

  // ========== OPTIMIZED MAP UPDATE ==========
  
  async function updateMap() {
    // Prevent concurrent updates
    if (updateInProgress) {
      console.log('Update already in progress, skipping...');
      return;
    }

    updateInProgress = true;

    try {
      const data = await getData();
      
      if (!data || data.length === 0) {
        updateInProgress = false;
        return;
      }

      // Update device status
      data.forEach(d => {
        deviceStatus[d.device_id] = d;
      });

      // Update legend
      updateLegend();

      // Clear layers efficiently
      markerGroup.clearLayers();
      labelGroup.clearLayers();
      miniLabelGroup.clearLayers();

      const bounds = [];
      const markers = [];
      const labels = [];
      const miniLabels = [];

      // Prepare all markers/labels before adding to map
      data.forEach(d => {
        if (!isFinite(d.lat) || !isFinite(d.lon)) return;

        const isOnline = d._time && (Date.now() - new Date(d._time).getTime() < 60000);
        const icon = getFlowIcon(d.Flowrate, isOnline);

        // Create marker
        const marker = L.marker([d.lat, d.lon], { icon })
          .on('mouseover', () => setHover(true, d.device_id))
          .on('mouseout', () => setHover(false, d.device_id))
          .on('click', () => map.flyTo([d.lat, d.lon], 18, { duration: 0.8 }));

        // Create full label HTML
        const labelHTML = `
          <div class="custom-label" id="label-${d.device_id}">
            <div class="device-id">${d.device_id}</div>
            <div class="info-row">
              <span class="label">Flowrate:</span>
              <span class="value">${d.Flowrate.toFixed(2)} l/s</span>
            </div>
            <div class="info-row">
              <span class="label">Totalizer:</span>
              <span class="value">${d.Totalizer.toFixed(0)} mÂ³</span>
            </div>
            <div class="info-row">
              <span class="label">Time:</span>
              <span class="value">${formatTime(d._time)}</span>
            </div>
          </div>
        `;

        const label = L.marker([d.lat, d.lon], {
          icon: L.divIcon({ className: '', html: labelHTML, iconAnchor: [0, 0] })
        })
          .on('mouseover', () => setHover(true, d.device_id))
          .on('mouseout', () => setHover(false, d.device_id))
          .on('click', () => map.flyTo([d.lat, d.lon], 18, { duration: 0.8 }));

        // Create mini label
        const miniLabel = L.marker([d.lat, d.lon], {
          icon: L.divIcon({
            className: '',
            html: `<div class="mini-label">${d.device_id}</div>`,
            iconAnchor: [28, 0]
          })
        })
          .on('click', () => map.flyTo([d.lat, d.lon], 18, { duration: 0.8 }));

        markers.push(marker);
        labels.push(label);
        miniLabels.push(miniLabel);
        bounds.push([d.lat, d.lon]);
      });

      // Batch add to layer groups
      markers.forEach(m => markerGroup.addLayer(m));
      labels.forEach(l => labelGroup.addLayer(l));
      miniLabels.forEach(ml => miniLabelGroup.addLayer(ml));

      // Update visibility
      if (!labelsVisible) {
        map.removeLayer(labelGroup);
        map.addLayer(miniLabelGroup);
      } else {
        map.addLayer(labelGroup);
        map.removeLayer(miniLabelGroup);
      }

      // Set initial bounds
      if (isFirstLoad && bounds.length > 0) {
        window.initialBounds = L.latLngBounds(bounds);
        map.fitBounds(initialBounds, {
          paddingTopLeft: [50, 50],
          paddingBottomRight: [120, 150],
          animate: true,
          duration: 0.8
        });
        isFirstLoad = false;
      }

      // Restore hover state
      if (isHoverLocked && hoveredDevice) {
        setHover(true, hoveredDevice);
      }

    } catch (error) {
      console.error('Update map error:', error);
    } finally {
      updateInProgress = false;
    }
  }

  // ========== TIME FORMATTING ==========
  
  function formatTime(timeString) {
    const dt = new Date(timeString);
    return `${dt.getDate()}/${dt.getMonth() + 1}/${dt.getFullYear()}, ${String(dt.getHours()).padStart(2, '0')}:${String(dt.getMinutes()).padStart(2, '0')}:${String(dt.getSeconds()).padStart(2, '0')}`;
  }

  // ========== SWITCH TOGGLE ==========
  
  document.addEventListener('change', e => {
    if (e.target.id === 'labelSwitch') {
      labelsVisible = e.target.checked;
      document.getElementById('switchLabel').innerText = labelsVisible ? 'Label ON' : 'Label OFF';
      
      if (labelsVisible) {
        map.addLayer(labelGroup);
        map.removeLayer(miniLabelGroup);
      } else {
        map.removeLayer(labelGroup);
        map.addLayer(miniLabelGroup);
      }
    }
  });

  // ========== VISIBILITY CHANGE HANDLER ==========
  
  let updateInterval;
  
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Pause updates when tab is not visible
      if (updateInterval) clearInterval(updateInterval);
    } else {
      // Resume updates when tab becomes visible
      updateMap();
      updateInterval = setInterval(updateMap, 5000);
    }
  });

  // ========== INITIAL LOAD ==========
  
  // Show loading indicator
  const loadingIndicator = document.getElementById('loadingIndicator');
  loadingIndicator.classList.add('show');

  // Initial map update
  updateMap().then(() => {
    loadingIndicator.classList.remove('show');
  });

  // Set update interval
  updateInterval = setInterval(updateMap, 5000);

  // ========== ERROR HANDLING ==========
  
  window.addEventListener('error', (e) => {
    console.error('Global error:', e.error);
  });

  // ========== MEMORY CLEANUP ==========
  
  window.addEventListener('beforeunload', () => {
    if (updateInterval) clearInterval(updateInterval);
    if (abortController) abortController.abort();
    map.remove();
  });
</script>

</body>
</html>